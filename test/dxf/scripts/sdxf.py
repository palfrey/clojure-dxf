#(c)www.stani.be (read __doc__ for more information)                            

__version__ = """v1.2 (11/16/08)"""
__author__  = "www.stani.be"
__license__ = "GPL"
__url__     = "http://www.stani.be/python/sdxf"
__doc__     = \
"""SDXF - Stani's DXF
Python library to generate dxf drawings

Copyright %s
Version %s
License %s
Homepage %s

Library by Stani, whose website is now defunct.
Modifications by Kelly Farrell (http://www.kellbot.com)
to support LWPOLYLINE.
""" % \
(__author__,__version__,__license__,__url__)

# TODO: support for Numeric/Numarray for speeding up
#_______________________________________________________________________________

import copy

newline = "\r\n"

####1) Private (only for developpers)
_HEADER_POINTS=['insbase','extmin','extmax']
#---helper functions
def _point(x,index=0):
    """Convert tuple to a dxf point"""
    return newline.join([('%s' + newline + '%s')%((i+1)*10+index,x[i]) for i in range(len(x))])

def _points(p):
    """Convert a list of tuples to dxf points"""
    return [_point(p[i],i)for i in range(len(p))]

#---base classes
class _Call:
    """Makes a callable class."""
    def copy(self):
        """Returns a copy."""
        return copy.deepcopy(self)
    def __call__(self,**attrs):
        """Returns a copy with modified attributes."""
        copied=self.copy()
        for attr in attrs:setattr(copied,attr,attrs[attr])
        return copied
    
class _Entity(_Call):
    """Base class for _common group codes for entities."""
    def __init__(self,color=None,extrusion=None,layer='PYDXF',
                 lineType=None,lineTypeScale=None,lineWeight=None,
                 thickness=None,parent=None):
        """None values will be omitted."""
        self.color          = color
        self.extrusion      = extrusion
        self.layer          = layer
        self.lineType       = lineType
        self.lineTypeScale  = lineTypeScale
        self.lineWeight     = lineWeight
        self.thickness      = thickness
        self.parent         = parent
        
    def _common(self):
        """Return common group codes as a string."""
        if self.parent:parent=self.parent
        else:parent=self
        result='8' + newline + '%s'%parent.layer
        if parent.color!=None:          result+= newline + '62' + newline + '%s'%parent.color
        if parent.extrusion!=None:      result+= newline + '%s'%_point(parent.extrusion,200)
        if parent.lineType!=None:       result+= newline + '6' + newline + '%s'%parent.lineType
        if parent.lineWeight!=None:     result+= newline + '370' + newline + '%s'%parent.lineWeight
        if parent.lineTypeScale!=None:  result+= newline + '48' + newline + '%s'%parent.lineTypeScale
        if parent.thickness!=None:      result+= newline + '39' + newline + '%s'%parent.thickness
        return result
    
class _Entities:
    """Base class to deal with composed objects."""
    def __dxf__(self):
        return []
        
    def __str__(self):
        return  newline.join([str(x) for x in self.__dxf__()])
        
class _Collection(_Call):
    """Base class to expose entities methods to main object."""
    def __init__(self,entities=[]):
        self.entities=copy.copy(entities)
        #link entities methods to drawing
        for attr in dir(self.entities):
            if attr[0]!='_':
                attrObject=getattr(self.entities,attr)
                if callable(attrObject):
                    setattr(self,attr,attrObject)

####2) Constants
#---color values
BYBLOCK=0
BYLAYER=256

#---block-type flags (bit coded values, may be combined): 
ANONYMOUS               =1  # This is an anonymous block generated by hatching, associative dimensioning, other internal operations, or an application
NON_CONSTANT_ATTRIBUTES =2  # This block has non-constant attribute definitions (this bit is not set if the block has any attribute definitions that are constant, or has no attribute definitions at all)
XREF                    =4  # This block is an external reference (xref)
XREF_OVERLAY            =8  # This block is an xref overlay 
EXTERNAL                =16 # This block is externally dependent
RESOLVED                =32 # This is a resolved external reference, or dependent of an external reference (ignored on input)
REFERENCED              =64 # This definition is a referenced external reference (ignored on input)

#---mtext flags
#attachment point
TOP_LEFT        = 1
TOP_CENTER      = 2
TOP_RIGHT       = 3
MIDDLE_LEFT     = 4
MIDDLE_CENTER   = 5
MIDDLE_RIGHT    = 6
BOTTOM_LEFT     = 7
BOTTOM_CENTER   = 8
BOTTOM_RIGHT    = 9
#drawing direction
LEFT_RIGHT      = 1
TOP_BOTTOM      = 3
BY_STYLE        = 5 #the flow direction is inherited from the associated text style
#line spacing style (optional): 
AT_LEAST        = 1 #taller characters will override
EXACT           = 2 #taller characters will not override

#---polyline flags
CLOSED                      =1      # This is a closed polyline (or a polygon mesh closed in the M direction)
CURVE_FIT                   =2      # Curve-fit vertices have been added
SPLINE_FIT                  =4      # Spline-fit vertices have been added
POLYLINE_3D                 =8      # This is a 3D polyline
POLYGON_MESH                =16     # This is a 3D polygon mesh
CLOSED_N                    =32     # The polygon mesh is closed in the N direction
POLYFACE_MESH               =64     # The polyline is a polyface mesh
CONTINOUS_LINETYPE_PATTERN  =128    # The linetype pattern is generated continuously around the vertices of this polyline

#---text flags
#horizontal
LEFT        = 0
CENTER      = 1
RIGHT       = 2
ALIGNED     = 3 #if vertical alignment = 0
MIDDLE      = 4 #if vertical alignment = 0
FIT         = 5 #if vertical alignment = 0
#vertical
BASELINE    = 0
BOTTOM      = 1
MIDDLE      = 2
TOP         = 3

####3) Classes
#---entitities
class Arc(_Entity):
    """Arc, angles in degrees."""
    def __init__(self,center=(0,0,0),radius=1,
                 startAngle=0.0,endAngle=90,**common):
        """Angles in degrees."""
        _Entity.__init__(self,**common)
        self.center=center
        self.radius=radius
        self.startAngle=startAngle
        self.endAngle=endAngle
    def __str__(self):
        return ('0' + newline + 'ARC' + newline + '%s' + newline + '%s' + newline + '40' + newline + '%s' + newline + '50' + newline + '%s' + newline + '51' + newline + '%s')%\
               (self._common(),_point(self.center),
                self.radius,self.startAngle,self.endAngle)

class Circle(_Entity):
    """Circle"""
    def __init__(self,center=(0,0,0),radius=1,**common):
        _Entity.__init__(self,**common)
        self.center=center
        self.radius=radius
    def __str__(self):
        return ('0' + newline + 'CIRCLE' + newline + '%s' + newline + '%s' + newline + '40' + newline + '%s')%\
               (self._common(),_point(self.center),self.radius)

class Face(_Entity):
    """3dface"""
    def __init__(self,points,**common):
        _Entity.__init__(self,**common)
        self.points=points
    def __str__(self):
        return  newline.join(['0' + newline + '3DFACE',self._common()]+
                         _points(self.points)
                         )

class Insert(_Entity):
    """Block instance."""
    def __init__(self,name,point=(0,0,0),
                 xscale=None,yscale=None,zscale=None,
                 cols=None,colspacing=None,rows=None,rowspacing=None,
                 rotation=None,
                 **common):
        _Entity.__init__(self,**common)
        self.name=name
        self.point=point
        self.xscale=xscale
        self.yscale=yscale
        self.zscale=zscale
        self.cols=cols
        self.colspacing=colspacing
        self.rows=rows
        self.rowspacing=rowspacing
        self.rotation=rotation
        
    def __str__(self):
        result=('0' + newline + 'INSERT' + newline + '2' + newline + '%s' + newline + '%s' + newline + '%s')%\
                (self.name,self._common(),_point(self.point))
        if self.xscale!=None:result+= newline + '41' + newline + '%s'%self.xscale
        if self.yscale!=None:result+= newline + '42' + newline + '%s'%self.yscale
        if self.zscale!=None:result+= newline + '43' + newline + '%s'%self.zscale
        if self.rotation:result+= newline + '50' + newline + '%s'%self.rotation
        if self.cols!=None:result+= newline + '70' + newline + '%s'%self.cols
        if self.colspacing!=None:result+= newline + '44' + newline + '%s'%self.colspacing
        if self.rows!=None:result+= newline + '71' + newline + '%s'%self.rows
        if self.rowspacing!=None:result+= newline + '45' + newline + '%s'%self.rowspacing
        return result
        
class Line(_Entity):
    """Line"""
    def __init__(self,points,**common):
        _Entity.__init__(self,**common)
        self.points=points
    def __str__(self):
        return newline.join(['0' + newline + 'LINE',self._common()]+
                         _points(self.points))

class LwPolyLine(_Entity):
    """This is a LWPOLYLINE. I have no idea how it differs from a normal PolyLine"""
    def __init__(self,points,flag=0,width=None,**common):
        _Entity.__init__(self,**common)
        self.points=points
        self.flag=flag
        self.width=width
    def __str__(self):
        result= ('0' + newline + 'LWPOLYLINE' + newline + '%s' + newline + '70' + newline + '%s')%\
            (self._common(),self.flag)
        result+= newline + '90' + newline + '%s'%len(self.points)
        for point in self.points:
            result+= newline + '%s'%_point(point)
        if self.width:result+= newline + '40' + newline + '%s' + newline + '41' + newline + '%s'%(self.width,self.width)
        return result


class PolyLine(_Entity):
	def __init__(self,points,org_point=[0,0,0],flag=0,width=None,**common):
		#width = number, or width = list [width_start=None, width_end=None]
		#for 2d-polyline: points = [ [x, y, z, width_start=None, width_end=None, bulge=0 or None], ...]
		#for 3d-polyline: points = [ [x, y, z], ...]
		#for polyface: points = [points_list, faces_list]
		_Entity.__init__(self,**common)
		self.points=points
		self.org_point=org_point
		self.flag=flag
		self.polyface = False
		self.polyline2d = False
		self.faces = [] # dummy value
		self.width= None # dummy value
		if self.flag & POLYFACE_MESH:
			self.polyface=True
			self.points=points[0]
			self.faces=points[1]
			self.p_count=len(self.points)
			self.f_count=len(self.faces)
		elif not self.flag & POLYLINE_3D:
			self.polyline2d = True
			if width:
				if type(width)!='list':
					width=[width,width]
				self.width=width

	def __str__(self):
		result= ('0' + newline + 'POLYLINE' + newline + '%s'+newline+'70' + newline + '%s' + newline)%(self._common(),self.flag)
		result+='66' + newline + '1' + newline
		result+=('%s' + newline)%_point(self.org_point)
		if self.polyface:
			result+=('71' + newline + '%s' + newline)%self.p_count
			result+=('72' + newline + '%s' + newline)%self.f_count
		elif self.polyline2d:
			if self.width!=None: result+=('40' + newline + '%s' + newline + '41' + newline + '%s' + newline)%(self.width[0],self.width[1])
		for point in self.points:
			result+='0' + newline + 'VERTEX' + newline
			result+=('8' + newline + '%s' + newline)%self.layer
			if self.polyface:
				result+=('%s' + newline)%_point(point[0:3])
				result+='70' + newline + '192' + newline
			elif self.polyline2d:
				result+=('%s' + newline)%_point(point[0:2])
				if len(point)>4:
					width1, width2 = point[3], point[4]
					if width1!=None: result+=('40' + newline + '%s' + newline)%width1
					if width2!=None: result+=('41' + newline + '%s' + newline) %width2
				if len(point)==6:
					bulge = point[5]
					if bulge: result+=('42' + newline + '%s' + newline)%bulge
			else:
				result+=('%s' + newline)%_point(point[0:3])
		for face in self.faces:
			result+='0' + newline + 'VERTEX' + newline
			result+=('8' + newline + '%s' + newline)%self.layer
			result+=('%s' + newline)%_point(self.org_point)
			result+='70' + newline + '128' + newline
			result+=('71' + newline + '%s' + newline)%face[0]
			result+=('72' + newline + '%s' + newline)%face[1]
			result+=('73' + newline + '%s' + newline)%face[2]
			if len(face)==4: result+=('74' + newline + '%s' + newline)%face[3]
		result+='0' + newline + 'SEQEND' + newline
		result+=('8' + newline + '%s')%self.layer
		return result

class Point(_Entity):
    """Colored solid fill."""
    def __init__(self,points=None,**common):
        _Entity.__init__(self,**common)
        self.points=points

class Solid(_Entity):
    """Colored solid fill."""
    def __init__(self,points=None,**common):
        _Entity.__init__(self,**common)
        self.points=points
    def __str__(self):
        return  newline.join(['0' + newline + 'SOLID',self._common()]+
                         _points(self.points[:2]+[self.points[3],self.points[2]])
                         )

class Text(_Entity):
    """Single text line."""
    def __init__(self,text='',point=(0,0,0),alignment=None,
                 flag=None,height=1,justifyhor=None,justifyver=None,
                 rotation=None,obliqueAngle=None,style=None,xscale=None,**common):
        _Entity.__init__(self,**common)
        self.text=text
        self.point=point
        self.alignment=alignment
        self.flag=flag
        self.height=height
        self.justifyhor=justifyhor
        self.justifyver=justifyver
        self.rotation=rotation
        self.obliqueAngle=obliqueAngle
        self.style=style
        self.xscale=xscale
    def __str__(self):
        result= ('0' + newline + 'TEXT' + newline + '%s' + newline + '%s' + newline + '40' + newline + '%s' + newline + '1' + newline + '%s')%\
                (self._common(),_point(self.point),self.height,self.text)
        if self.rotation:result+= newline + '50' + newline + '%s'%self.rotation
        if self.xscale:result+= newline + '41' + newline + '%s'%self.xscale
        if self.obliqueAngle:result+= newline + '51' + newline + '%s'%self.obliqueAngle
        if self.style:result+= newline + '7' + newline + '%s'%self.style.name.upper()
        if self.flag:result+= newline + '71' + newline + '%s'%self.flag
        if self.justifyhor:result+= newline + '72' + newline + '%s'%self.justifyhor
        if self.alignment:result+= newline + '%s'%_point(self.alignment,1)
        if self.justifyver:result+= newline + '73' + newline + '%s'%self.justifyver
        return result

class Mtext(Text):
    """Surrogate for mtext, generates some Text instances."""
    def __init__(self,text='',point=(0,0,0),width=250,spacingFactor=1.5,down=False,spacingWidth=None,**options):
        Text.__init__(self,text=text,point=point,**options)
        if down:spacingFactor*=-1
        self.spacingFactor=spacingFactor
        self.spacingWidth=spacingWidth
        self.width=width
        self.down=down
    def __str__(self):
        texts=self.text.split(newline)
        if not self.down:texts.reverse()
        result=''
        x=y=0
        if self.spacingWidth:spacingWidth=self.spacingWidth
        else:spacingWidth=self.height*self.spacingFactor
        for text in texts:
            while text:
                result+= newline + '%s'%Text(text[:self.width],
                    point=(self.point[0]+x*spacingWidth,
                           self.point[1]+y*spacingWidth,
                           self.point[2]),
                    alignment=self.alignment,flag=self.flag,height=self.height,
                    justifyhor=self.justifyhor,justifyver=self.justifyver,
                    rotation=self.rotation,obliqueAngle=self.obliqueAngle,
                    style=self.style,xscale=self.xscale,parent=self
                )
                text=text[self.width:]
                if self.rotation:x+=1
                else:y+=1
        return result[1:]
        
##class _Mtext(_Entity):
##    """Mtext not functioning for minimal dxf."""
##    def __init__(self,text='',point=(0,0,0),attachment=1,
##                 charWidth=None,charHeight=1,direction=1,height=100,rotation=0,
##                 spacingStyle=None,spacingFactor=None,style=None,width=100,
##                 xdirection=None,**common):
##        _Entity.__init__(self,**common)
##        self.text=text
##        self.point=point
##        self.attachment=attachment
##        self.charWidth=charWidth
##        self.charHeight=charHeight
##        self.direction=direction
##        self.height=height
##        self.rotation=rotation
##        self.spacingStyle=spacingStyle
##        self.spacingFactor=spacingFactor
##        self.style=style
##        self.width=width
##        self.xdirection=xdirection
##    def __str__(self):
##        input=self.text
##        text=''
##        while len(input)>250:
##            text+= newline + '3' + newline + '%s'%input[:250]
##            input=input[250:]
##        text+= newline + '1' + newline + '%s'%input
##        result= '0' + newline + 'MTEXT' + newline + '%s' + newline + '%s' + newline + '40' + newline + '%s' + newline + '41' + newline + '%s' + newline + '71' + newline + '%s' + newline + '72' + newline + '%s%s' + newline + '43' + newline + '%s' + newline + '50' + newline + '%s'%\
##                (self._common(),_point(self.point),self.charHeight,self.width,
##                 self.attachment,self.direction,text,
##                 self.height,
##                 self.rotation)
##        if self.style:result+= newline + '7' + newline + '%s'%self.style
##        if self.xdirection:result+= newline + '%s'%_point(self.xdirection,1)
##        if self.charWidth:result+= newline + '42' + newline + '%s'%self.charWidth
##        if self.spacingStyle:result+= newline + '73' + newline + '%s'%self.spacingStyle
##        if self.spacingFactor:result+= newline + '44' + newline + '%s'%self.spacingFactor
##        return result
    
#---tables
class Block(_Collection):
    """Use list methods to add entities, eg append."""
    def __init__(self,name,layer='PYDXF',flag=0,base=(0,0,0),entities=[]):
        self.entities=copy.copy(entities)
        _Collection.__init__(self,entities)
        self.layer=layer
        self.name=name
        self.flag=0
        self.base=base
    def __str__(self):
        e= newline.join([str(x)for x in self.entities])
        return ('0' + newline + 'BLOCK' + newline + '8' + newline + '%s' + newline + '2' + newline + '%s' + newline + '70' + newline + '%s' + newline + '%s' + newline + '3' + newline + '%s' + newline + '%s' + newline + '0' + newline + 'ENDBLK')%\
               (self.layer,self.name.upper(),self.flag,_point(self.base),self.name.upper(),e)
            
class Layer(_Call):
    """Layer"""
    def __init__(self,name='PYDXF',color=7,lineType='continuous',flag=64):
        self.name=name
        self.color=color
        self.lineType=lineType
        self.flag=flag
    def __repr__(self):
        return "<sdxf.Layer: %s>"%self.name
    def __str__(self):
        return ('0' + newline + 'LAYER' + newline + '2' + newline + '%s' + newline + '70' + newline + '%s' + newline + '62' + newline + '%s' + newline + '6' + newline + '%s')%\
               (self.name.upper(),self.flag,self.color,self.lineType)
    
class LineType(_Call):
    """Custom linetype"""
    def __init__(self,name='continuous',description='Solid line',elements=[],flag=64):
        # TODO: Implement lineType elements
        self.name=name
        self.description=description
        self.elements=copy.copy(elements)
        self.flag=flag
    def __str__(self):
        return ('0' + newline + 'LTYPE' + newline + '2' + newline + '%s' + newline + '70' + newline + '%s' + newline + '3' + newline + '%s' + newline + '72' + newline + '65' + newline + '73' + newline + '%s' + newline + '40' + newline + '0.0')%\
            (self.name.upper(),self.flag,self.description,len(self.elements))

class Style(_Call):
    """Text style"""
    def __init__(self,name='standard',flag=0,height=0,widthFactor=40,obliqueAngle=50,
                 mirror=0,lastHeight=1,font='arial.ttf',bigFont=''):
        self.name=name
        self.flag=flag
        self.height=height
        self.widthFactor=widthFactor
        self.obliqueAngle=obliqueAngle
        self.mirror=mirror
        self.lastHeight=lastHeight
        self.font=font
        self.bigFont=bigFont
    def __str__(self):
        return ('0' + newline + 'STYLE' + newline + '2' + newline + '%s' + newline + '70' + newline + '%s' + newline + '40' + newline + '%s' + newline + '41' + newline + '%s' + newline + '50' + newline + '%s' + newline + '71' + newline + '%s' + newline + '42' + newline + '%s' + newline + '3' + newline + '%s' + newline + '4' + newline + '%s')%\
               (self.name.upper(),self.flag,self.flag,self.widthFactor,
                self.obliqueAngle,self.mirror,self.lastHeight,
                self.font.upper(),self.bigFont.upper())

class View(_Call):
    def __init__(self,name,flag=0,width=1,height=1,center=(0.5,0.5),
                 direction=(0,0,1),target=(0,0,0),lens=50,
                 frontClipping=0,backClipping=0,twist=0,mode=0):
        self.name=name
        self.flag=flag
        self.width=width
        self.height=height
        self.center=center
        self.direction=direction
        self.target=target
        self.lens=lens
        self.frontClipping=frontClipping
        self.backClipping=backClipping
        self.twist=twist
        self.mode=mode
    def __str__(self):
        return ('0' + newline + 'VIEW' + newline + '2' + newline + '%s' + newline + '70' + newline + '%s' + newline + '40' + newline + '%s' + newline + '%s' + newline + '41' + newline + '%s' + newline + '%s' + newline + '%s' + newline + '42' + newline + '%s' + newline + '43' + newline + '%s' + newline + '44' + newline + '%s' + newline + '50' + newline + '%s' + newline + '71' + newline + '%s')%\
               (self.name,self.flag,self.height,_point(self.center),self.width,
                _point(self.direction,1),_point(self.target,2),self.lens,
                self.frontClipping,self.backClipping,self.twist,self.mode)

def ViewByWindow(name,leftBottom=(0,0),rightTop=(1,1),**options):
    width=abs(rightTop[0]-leftBottom[0])
    height=abs(rightTop[1]-leftBottom[1])
    center=((rightTop[0]+leftBottom[0])*0.5,(rightTop[1]+leftBottom[1])*0.5)
    return View(name=name,width=width,height=height,center=center,**options)

#---drawing
class Drawing(_Collection):
    """Dxf drawing. Use append or any other list methods to add objects."""
    def __init__(self,insbase=(0.0,0.0,0.0),extmin=(0.0,0.0),extmax=(0.0,0.0),
                 layers=[Layer()],linetypes=[LineType()],styles=[Style()],blocks=[],
                 views=[],entities=None,fileName='test.dxf'):
        # TODO: replace list with None,arial
        if not entities:entities=[]
        _Collection.__init__(self,entities)
        self.insbase=insbase
        self.extmin=extmin
        self.extmax=extmax
        self.layers=copy.copy(layers)
        self.linetypes=copy.copy(linetypes)
        self.styles=copy.copy(styles)
        self.views=copy.copy(views)
        self.blocks=copy.copy(blocks)
        self.fileName=fileName
        #private
        self.acadver='9' + newline + '$ACADVER' + newline + '1' + newline + 'AC1006'
    def _name(self,x):
        """Helper function for self._point"""
        return '10' + newline + '$%s'%x.upper()
    def _point(self,name,x):
        """Point setting from drawing like extmin,extmax,..."""
        return ('%s' + newline + '%s')%(self._name(name),_point(x))
    def _section(self,name,x):
        """Sections like tables,blocks,entities,..."""
        if x:xstr= newline + newline.join(x)
        else:xstr=''
        return ('0' + newline + 'SECTION' + newline + '2' + newline + '%s%s' + newline + '0' + newline + 'ENDSEC')%(name.upper(),xstr)
    def _table(self,name,x):
        """Tables like ltype,layer,style,..."""
        if x:xstr= newline + newline.join(x)
        else:xstr=''
        return ('0' + newline + 'TABLE' + newline + '2' + newline + '%s' + newline + '70' + newline + '%s%s' + newline + '0' + newline + 'ENDTAB')%(name.upper(),len(x),xstr)
    def __str__(self):
        """Returns drawing as dxf string."""
        header=[self.acadver]+[self._point(attr,getattr(self,attr)) for attr in _HEADER_POINTS]
        header=self._section('header',header)
        
        tables=[self._table('ltype',[str(x) for x in self.linetypes]),
                self._table('layer',[str(x) for x in self.layers]),
                self._table('style',[str(x) for x in self.styles]),
                self._table('view',[str(x) for x in self.views]),
        ]
        tables=self._section('tables',tables)

        blocks=self._section('blocks',[str(x) for x in self.blocks])

        entities=self._section('entities',[str(x) for x in self.entities])
        
        all= newline.join([header,tables,blocks,entities,'0' + newline + 'EOF' + newline])
        return all
    def saveas(self,fileName):
        self.fileName=fileName
        self.save()
    def save(self):
        test=open(self.fileName,'wb')
        data = str(self).split(newline)
        out = []
        for line in data:
            if len(line)<3:
                line = " "*(3-len(line))+line
            out.append(line)
        test.write(newline.join(out))
        test.close()

#---extras
class Rectangle(_Entity):
    """Rectangle, creates lines."""
    def __init__(self,point=(0,0,0),width=1,height=1,solid=None,line=1,**common):
        _Entity.__init__(self,**common)
        self.point=point
        self.width=width
        self.height=height
        self.solid=solid
        self.line=line
    def __str__(self):
        result=''
        points=[self.point,(self.point[0]+self.width,self.point[1],self.point[2]),
            (self.point[0]+self.width,self.point[1]+self.height,self.point[2]),
            (self.point[0],self.point[1]+self.height,self.point[2]),self.point]
        if self.solid:
            result+= newline + '%s'%Solid(points=points[:-1],parent=self.solid)
        if self.line:
            for i in range(4):result+= newline + '%s'%\
                Line(points=[points[i],points[i+1]],parent=self)
        return result[1:]

class LineList(_Entity):
    """Like polyline, but built of individual lines."""
    def __init__(self,points=[],closed=0,**common):
        _Entity.__init__(self,**common)
        self.closed=closed
        self.points=copy.copy(points)
    def __str__(self):
        if self.closed:points=self.points+[self.points[0]]
        else: points=self.points
        result=''
        for i in range(len(points)-1):result+= newline + '%s'%\
            Line(points=[points[i],points[i+1]],parent=self)
        return result[1:]

#PolyLine=LineList
#---test
def main():
    #Blocks
    b=Block('test')
    b.append(Solid(points=[(0,0,0),(1,0,0),(1,1,0),(0,1,0)],color=1))
    b.append(Arc(center=(1,0,0),color=2))
    
    #Drawing
    d=Drawing()
    #tables
    d.blocks.append(b)                      #table blocks
    d.styles.append(Style())                #table styles
    d.views.append(View('Normal'))          #table view
    d.views.append(ViewByWindow('Window',leftBottom=(1,0),rightTop=(2,1)))  #idem

    #entities
    d.append(Circle(center=(1,1,0),color=3))
    d.append(Face(points=[(0,0,0),(1,0,0),(1,1,0),(0,1,0)],color=4))
    d.append(Insert('test',point=(3,3,3),cols=5,colspacing=2))
    d.append(Line(points=[(0,0,0),(1,1,1)]))
    d.append(Mtext('Click on Ads' + newline + 'multiple lines with mtext',point=(1,1,1),color=5,rotation=90))
    d.append(Text('Please donate!',point=(3,0,1)))
    d.append(Rectangle(point=(2,2,2),width=4,height=3,color=6,solid=Solid(color=2)))
    d.append(Solid(points=[(4,4,0),(5,4,0),(7,8,0),(9,9,0)],color=3))
    d.append(PolyLine(points=[(1,1,1),(2,1,1),(2,2,1),(1,2,1)],flag=CLOSED,color=1))
    
    print(d)

if __name__=='__main__':main()
